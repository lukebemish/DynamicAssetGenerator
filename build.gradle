import groovy.json.JsonOutput
import groovy.json.JsonSlurper

plugins {
    id 'maven-publish'
    id 'signing'
    id 'java-library'
    alias libs.plugins.managedversioning
    alias libs.plugins.modsdotgroovy
}

managedVersioning {
    versionFile.set rootProject.file('version.properties')
    metadataVersion.set libs.versions.minecraft
    versionPRs()
    versionSnapshots()

    gitHubActions {
        snapshot {
            prettyName.set 'Snapshot'
            workflowDispatch.set(true)
            onBranches.add '1.*'
            gradleJob {
                name.set 'build'
                javaVersion.set '21'
                gradlew 'Build', 'checkLicenses', 'build'
                gradlew 'Publish', 'publish'
                mavenSnapshot('github')
            }
        }
        release {
            prettyName.set 'Release'
            workflowDispatch.set(true)
            gradleJob {
                name.set 'build'
                javaVersion.set '21'
                buildCache()
                step {
                    setupGitUser()
                }
                readOnly.set false
                gradlew 'Tag Release', 'tagRelease'
                gradlew 'Build', 'build'
                step {
                    run.set 'git push && git push --tags'
                }
                recordVersion 'Record Version', 'version'
                sign()
                mavenCentral()
                modPublishing()
            }
            gradleJob {
                name.set 'publishCentral'
                javaVersion.set '21'
                buildCache()
                name.set 'publish'
                needs.add('build')
                tag.set('${{needs.build.outputs.version}}')
                gradlew 'Publish', 'publish', 'closeAndReleaseSonatypeStagingRepository'
                sign()
                mavenCentral()
                modPublishing()
            }
            gradleJob {
                name.set 'publishMod'
                javaVersion.set '21'
                buildCache()
                name.set 'publish'
                needs.add('build')
                tag.set('${{needs.build.outputs.version}}')
                gradlew 'Publish', 'modrinth', 'curseforge'
                sign()
                mavenCentral()
                modPublishing()
            }
            gradleJob {
                name.set 'publishJavadoc'
                javaVersion.set '21'
                buildCache()
                name.set 'publish'
                needs.add('build')
                tag.set('${{needs.build.outputs.version}}')
                gradlew 'Build', 'prepareJavadoc'
                step {
                    name.set 'Upload Javadoc'
                    uses.set 'andreiio/rclone-action@v1.2.0'
                    with['args'] = 'copy build/prepareJavadoc r2:javadoc-lukebemish-dev'
                    env['RCLONE_CONFIG_R2_TYPE'] = 's3'
                    secret 'RCLONE_CONFIG_R2_ACCESS_KEY_ID', 'JAVADOC_ACCESS_KEY_ID'
                    secret 'RCLONE_CONFIG_R2_SECRET_ACCESS_KEY', 'JAVADOC_SECRET_ACCESS_KEY'
                    secret 'RCLONE_CONFIG_R2_ENDPOINT', 'JAVADOC_ENDPOINT'
                    env['RCLONE_CONFIG_R2_PROVIDER'] = 'Cloudflare'
                    env['RCLONE_CONFIG_R2_REGION'] = 'auto'
                    env['RCLONE_CONFIG_R2_ACL'] = 'private'
                }
                sign()
                mavenCentral()
                modPublishing()
            }
        }
        build_pr {
            prettyName.set 'Build PR'
            pullRequest.set(true)
            gradleJob {
                name.set 'build'
                javaVersion.set '21'
                gradlew 'Build', 'checkLicenses', 'build'
                gradlew 'Publish', 'publish'
                pullRequestArtifact()
            }
        }
        publish_pr {
            prettyName.set 'Publish PR'
            publishPullRequestAction(
                'github',
                'dev/lukebemish/dynamicassetgenerator/dynamicassetgenerator-*',
                'Build PR'
            )
        }
    }
}

managedVersioning.apply()

println "Building: $version"

modsDotGroovy {
    multiplatform.expose()
    gather {
        projectProperty('mod_id')
        projectProperty('mod_name')
        projectProperty('description')
    }
}

import org.groovymc.modsdotgroovy.core.Platform

sourceSets.neoforge.modsDotGroovy {
    platform = Platform.NEOFORGE
    inferGather.set false
    multiplatform.from(':', 'main')
    gather {
        minecraftVersion = libs.versions.minecraft.get()
        platformVersion = libs.versions.neoforge.get()
    }
    enable()
}

sourceSets.fabric.modsDotGroovy {
    platform = Platform.FABRIC
    inferGather.set false
    multiplatform.from(':', 'main')
    gather {
        minecraftVersion = libs.versions.minecraft.get()
        platformVersion = libs.versions.fabric.loader.get()
    }
    enable()
}

dependencies {
    compileOnly cLibs.bundles.compileonly
    annotationProcessor cLibs.bundles.annotationprocessor
    compileOnly libs.fabric.mixin

    fabricCompileOnly cLibs.bundles.compileonly
    fabricAnnotationProcessor cLibs.bundles.annotationprocessor
    modFabricImplementation libs.fabric.loader
    modFabricImplementation libs.fabric.api
    modFabricCompileOnly libs.owolib

    neoforgeCompileOnly cLibs.bundles.compileonly
    neoforgeAnnotationProcessor cLibs.bundles.annotationprocessor
}

java.toolchain.languageVersion = JavaLanguageVersion.of(21)

java {
    withSourcesJar()
    withJavadocJar()
    registerFeature("neoforge") {
        usingSourceSet sourceSets.neoforge
        capability(project.group as String, project.name, project.version as String)
        capability(project.group as String, "$project.name-neoforge", project.version as String)
        withSourcesJar()
        withJavadocJar()
    }
    registerFeature("fabric") {
        usingSourceSet sourceSets.fabric
        capability(project.group as String, project.name, project.version as String)
        capability(project.group as String, "$project.name-fabric", project.version as String)
        withSourcesJar()
        withJavadocJar()
    }
}

managedVersioning.publishing.mavenCentral()
managedVersioning.publishing.mavenPullRequest(publishing)
managedVersioning.publishing.mavenSnapshot(publishing)

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java
            managedVersioning.publishing.sign(project.signing, it)
        }
    }
}

['javadoc', 'fabricJavadoc', 'neoforgeJavadoc'].each {
    tasks.named(it, Javadoc) {
        include "**/api/**"
    }
}

['sourcesJar', 'fabricSourcesJar', 'neoforgeSourcesJar'].each {
    tasks.named(it, Jar) {
        from(files("LICENSE")) {
            rename { "${it}_${project.name}" }
        }
    }
}

['jar', 'fabricJar', 'neoforgeJar'].each {
    tasks.named(it, Jar) {
        from(files("LICENSE")) {
            rename { "${it}_${project.name}" }
        }

        manifest {
            attributes([
                'Specification-Title'     : mod_name,
                'Specification-Vendor'    : mod_author,
                'Specification-Version'   : project.version,
                'Implementation-Title'    : "$mod_name - ${project.name}",
                'Implementation-Version'  : project.version,
                'Implementation-Vendor'   : mod_author,
                'Built-On-Minecraft'      : libs.versions.minecraft.get(),
                'Implementation-Commit-Time': managedVersioning.timestamp.get(),
                'Implementation-Commit': managedVersioning.hash.get()
            ])
        }
    }
}

processNeoforgeResources {
    doLast {
        fileTree(dir: outputs.files.asPath, include: "mixin.*.json").each { File file ->
            def obj = new JsonSlurper().parse(file)
            if (obj['refmap']) {
                obj.remove('refmap')
            }
            file.text = JsonOutput.toJson(obj)
        }
    }
}

tasks.register('combinedJavadoc', Javadoc) {
    source sourceSets.main.allJava
    source sourceSets.fabric.allJava
    source sourceSets.neoforge.allJava
    def files = files()
    [configurations.compileClasspath, configurations.fabricCompileClasspath, configurations.neoforgeCompileClasspath].each {
        files.from it
        dependsOn it
    }
    classpath = files
    include "**/api/**"
}

tasks.register('prepareJavadoc', Copy) {
    dependsOn tasks.combinedJavadoc
    from tasks.combinedJavadoc.outputs
    into layout.buildDirectory.dir("prepareJavadoc/${(project.group as String).replace('.','/')}/${(project.version as String).split(/\./)[0]}")
}

tasks.named('assemble') {
    dependsOn tasks.prepareJavadoc
}
